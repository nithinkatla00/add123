var Immutable, matchHelper, o, queryParse, trimSlash;

Immutable = require('immutable');

exports.trimSlash = trimSlash = function(chunk) {
  if (chunk.substr(0, 1) === '/') {
    return trimSlash(chunk.substr(1));
  } else if (chunk.substr(-1) === '/') {
    return trimSlash(chunk.substr(0, chunk.length - 1));
  } else {
    return chunk;
  }
};

exports.queryParse = queryParse = function(data, chunks) {
  var chunk, key, pieces, value;
  if (chunks.size === 0) {
    return data;
  } else {
    chunk = chunks.first();
    pieces = chunk.split('=');
    key = pieces[0], value = pieces[1];
    key = decodeURIComponent(key);
    value = decodeURIComponent(value);
    return queryParse(data.set(key, value), chunks.slice(1));
  }
};

o = Immutable.Map();

exports.parse = function(segment) {
  var chunkPath, chunkQuery, ref, thePath, theQuery;
  ref = segment.split('?'), chunkPath = ref[0], chunkQuery = ref[1];
  chunkPath = trimSlash(chunkPath);
  chunkQuery = chunkQuery || '';
  thePath = chunkPath.length > 0 ? chunkPath.split('/') : [];
  thePath = thePath.map(decodeURIComponent);
  if (chunkQuery.length > 0) {
    theQuery = queryParse(o, Immutable.fromJS(chunkQuery.split('&')));
  } else {
    theQuery = o;
  }
  return Immutable.fromJS({
    path: thePath,
    query: theQuery
  });
};

exports.stringify = function(info) {
  var stringPath, stringQuery;
  stringPath = info.get('path').map(encodeURIComponent).join('/');
  stringQuery = info.get('query').filter(function(value, key) {
    return value != null;
  }).map(function(value, key) {
    key = encodeURIComponent(key);
    value = encodeURIComponent(value);
    return key + "=" + value;
  }).join('&');
  if (stringQuery.length > 0) {
    return "/" + stringPath + "?" + stringQuery;
  } else {
    return "/" + stringPath;
  }
};

exports.fill = function(pieces, data) {
  return pieces.map(function(chunk) {
    if (chunk.substr(0, 1) === ':') {
      return data.get(chunk.substr(1));
    } else {
      return chunk;
    }
  });
};

matchHelper = function(pieces, rulePieces, result) {
  var allEnd, allLong, newResult, piece, rule;
  allLong = pieces.size > 0 && rulePieces.size > 0;
  allEnd = pieces.size === 0 && rulePieces.size === 0;
  switch (false) {
    case !result.get('skipped'):
      return result;
    case !allEnd:
      return result;
    case !allLong:
      rule = rulePieces.get(0);
      piece = pieces.get(0);
      switch (false) {
        case rule !== '~':
          return result.set('skipped', true);
        case rule.substr(0, 1) !== ':':
          newResult = result.setIn(['data', rule.substr(1)], piece);
          return matchHelper(pieces.slice(1), rulePieces.slice(1), newResult);
        case rule !== piece:
          return matchHelper(pieces.slice(1), rulePieces.slice(1), result);
        default:
          return result.set('failed', true);
      }
      break;
    default:
      return result.set('failed', true);
  }
};

exports.match = function(pieces, rulePieces) {
  var result;
  result = matchHelper(pieces, rulePieces, Immutable.fromJS({
    failed: false,
    skipped: false,
    data: {}
  }));
  return result;
};

exports.getCurrentInfo = function(rules, address) {
  var addressInfo, info, targetRule;
  addressInfo = exports.parse(address);
  targetRule = rules.reduce(function(acc, rule) {
    var result;
    if (acc.get('failed')) {
      result = exports.match(addressInfo.get('path'), rule.get('path'));
      return result.set('name', rule.get('name'));
    } else {
      return acc;
    }
  }, Immutable.fromJS({
    failed: true
  }));
  info = null;
  if (targetRule.get('failed')) {
    return Immutable.Map({
      name: '404',
      data: null,
      query: addressInfo.get('query')
    });
  } else {
    return Immutable.Map({
      name: targetRule.get('name'),
      data: targetRule.get('data'),
      query: addressInfo.get('query')
    });
  }
};

exports.expandRoutes = function(rules) {
  return Immutable.fromJS(rules).map(function(pair) {
    var info, name, rule;
    name = pair.get(0);
    rule = pair.get(1);
    info = exports.parse(rule);
    return info.set('name', name);
  });
};

exports.makeAddress = function(expandedRoutes, route) {
  var info, newInfo;
  info = expandedRoutes.find(function(ruleInfo) {
    return ruleInfo.get('name') === route.get('name');
  });
  newInfo = info.set('path', exports.fill(info.get('path'), route.get('data'))).set('query', route.get('query'));
  return exports.stringify(newInfo);
};
